1、从排序数组中删除重复项

  给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度
  不要使用额外的数组空间，你必须在原地修改输入数组饼在使用 O(1) 额外空间的条件下完成。

  示例 1:
  给定数组 nums = [1,1,2],
  函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
  你不需要考虑数组中超出新长度后面的元素。

  示例 2:
  给定 nums = [0,0,1,1,1,2,2,3,3,4],
  函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
  你不需要考虑数组中超出新长度后面的元素。

2、买卖股票的最佳时机 II

  给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
  设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）
  注意：你不能同事参与多笔交易（你必须再次购买前出售之前的股票）。

  示例 1:
  输入: [7,1,5,3,6,4]
  输出: 7
  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
  随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
  
  示例 2:
  输入: [1,2,3,4,5]
  输出: 4
  解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
  注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
  因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

  示例 3:
  输入: [7,6,4,3,1]
  输出: 0
  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

4、存在重复

  给定一个整数数组，判断是否存在重复元素。
  如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

  示例 1:
  输入: [1,2,3,1]
  输出: true

  示例 2:
  输入: [1,2,3,4]
  输出: false

  示例 3:
  输入: [1,1,1,3,3,4,3,2,4,2]
  输出: true

5、只出现一次的数

  给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
  说明：
  你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

  示例 1:
  输入: [2,2,1]
  输出: 1

  示例 2:
  输入: [4,1,2,1,2]
  输出: 4

8、移动零

  给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

  示例:
  输入: [0,1,0,3,12]
  输出: [1,3,12,0,0]

  说明:
  必须在原数组上操作，不能拷贝额外的数组。
  尽量减少操作次数。

9、两数之和

  给定一个整数数组 nums 和一个目标值 target，请你在改数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
  你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

  示例:
  给定 nums = [2, 7, 11, 15], target = 9
  因为 nums[0] + nums[1] = 2 + 7 = 9
  所以返回 [0, 1]