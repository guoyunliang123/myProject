1、两数之和

  给定一个整数数组 nums 和一个目标值 target，请你在改数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
  你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

  示例:
  给定 nums = [2, 7, 11, 15], target = 9
  因为 nums[0] + nums[1] = 2 + 7 = 9
  所以返回 [0, 1]

26、从排序数组中删除重复项

  给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度
  不要使用额外的数组空间，你必须在原地修改输入数组饼在使用 O(1) 额外空间的条件下完成。

  示例 1:
  给定数组 nums = [1,1,2],
  函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
  你不需要考虑数组中超出新长度后面的元素。

  示例 2:
  给定 nums = [0,0,1,1,1,2,2,3,3,4],
  函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
  你不需要考虑数组中超出新长度后面的元素。

27、移除元素

  给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
  不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

  示例 1:
  给定 nums = [3,2,2,3], val = 3,
  函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
  你不需要考虑数组中超出新长度后面的元素。

  示例 2:
  给定 nums = [0,1,2,2,3,0,4,2], val = 2,
  函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
  注意这五个元素可为任意顺序。
  你不需要考虑数组中超出新长度后面的元素

35、搜索插入位置

  给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
  你可以假设数组中无重复元素。

  示例 1:
  输入: [1,3,5,6], 5
  输出: 2

  示例 2:
  输入: [1,3,5,6], 2
  输出: 1

  示例 3:
  输入: [1,3,5,6], 7
  输出: 4

  示例 4:
  输入: [1,3,5,6], 0
  输出: 0

53、最大子序和

  给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

  示例:
  输入: [-2,1,-3,4,-1,2,1,-5,4],
  输出: 6

  解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

66、加一

  给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
  高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
  你可以假设除了整数 0 之外，这个整数不会以零开头。

  示例 1:
  输入: [1,2,3]
  输出: [1,2,4]
  解释: 输入数组表示数字 123。

  示例 2:
  输入: [4,3,2,1]
  输出: [4,3,2,2]
  解释: 输入数组表示数字 4321。

88、合并两个有序数组

  给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

  说明:
  初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
  你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

  示例:

  输入:
  nums1 = [1,2,3,0,0,0], m = 3
  nums2 = [2,5,6],       n = 3
  输出: [1,2,2,3,5,6]

121、买卖股票的最佳时机

  给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
  如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
  注意你不能在买入股票前卖出股票。

  示例 1:
  输入: [7,1,5,3,6,4]
  输出: 5

  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
        注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

  示例 2:
  输入: [7,6,4,3,1]
  输出: 0

  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

122、买卖股票的最佳时机 II

  给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
  设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

  示例 1:
  输入: [7,1,5,3,6,4]
  输出: 7
  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
       随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

  示例 2:
  输入: [1,2,3,4,5]
  输出: 4
  解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
       注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
       因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

  示例 3:
  输入: [7,6,4,3,1]
  输出: 0
  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

136、只出现一次的数

  给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
  说明：
  你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

  示例 1:
  输入: [2,2,1]
  输出: 1

  示例 2:
  输入: [4,1,2,1,2]
  输出: 4

169、多数元素

  给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
  你可以假设数组是非空的，并且给定的数组总是存在多数元素。

  示例 1:
  输入: [3,2,3]
  输出: 3

  示例 2:
  输入: [2,2,1,1,1,2,2]
  输出: 2

217、存在重复

  给定一个整数数组，判断是否存在重复元素。
  如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

  示例 1:
  输入: [1,2,3,1]
  输出: true

  示例 2:
  输入: [1,2,3,4]
  输出: false

  示例 3:
  输入: [1,1,1,3,3,4,3,2,4,2]
  输出: true

291、存在重复元素 II

  给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。

  示例 1:
  输入: nums = [1,2,3,1], k = 3
  输出: true

  示例 2:
  输入: nums = [1,0,1,1], k = 1
  输出: true

  示例 3:
  输入: nums = [1,2,3,1,2,3], k = 2
  输出: false

268、缺失数字

给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

  示例 1:
  输入: [3,0,1]
  输出: 2

  示例 2:
  输入: [9,6,4,2,3,5,7,0,1]
  输出: 8

283、移动零

  给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

  示例:
  输入: [0,1,0,3,12]
  输出: [1,3,12,0,0]

  说明:
  必须在原数组上操作，不能拷贝额外的数组。
  尽量减少操作次数。
